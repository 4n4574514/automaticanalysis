%% Automatic analysis - do processing with parallel engine
% Main engine which runs different stages
% Pass parameter file set up in aa_user.m with help of recipes.
% Rhodri Cusack MRC CBU Cambridge 2004-2008
% Second parameter in parallel version specifies to allow exisiting worker
% pool to continue
% function [aap]=aa_doprocessing_parallel(aap,dontcloseexistingworkers)
%
% Major revision July 2008:
%  Divided phase of launching workers (and allocating jobs to them) for the phase
%  of passing the details to them once they're ready to work. This means
%  many workers can prepare for work simultaneously, and then be handed
%  their allocated jobs together. It makes everything more snappy.
% [RC]
%
% Added 'internal' domain, for allowing modules to parallelise over their
% own vaiables (djm)
%

% March 2009-April 2010
%  Support for AWS being included
% [RC]

% 2010-03-17: There has been a major change in the dependency description.
% Previously, the 'tobecompletedfirst' field alone determined what stages
% were required before others. Now, however, the 'tobecompletedfirst'
% describes a chain describing the basic pipeline. For each stage, this
% chain is then analyzed to find the stages that provide the outputs that
% this stage needs as input. Then, only these stages are actually defined
% as dependencies. Other stages that don't provide outputs that are used by
% the current stage, but are earlier in the 'tobecompletedfirst' pipeline,
% are not marked as dependencies.
% [RC]

function [aap]=aa_doprocessing(aap,username,secretkey,bucket,bucketfordicom)

% launch SPM if not already running
try
    if (isempty(spm_figure('FindWin')))
        spm('fmri');
    end;
catch
    spm('fmri');
end;

% Check this is compiled
try
    utc_time();
catch
    fprintf('You must compile the utc_time library\n')
end;

%
if (isstr(aap))
    tmp=load(aap);
    aap=tmp.aap;
    if (~exist('username','var'))
        username=tmp.username;
    end;
    if (~exist('bucket','var'))
        bucket=tmp.bucket;
    end;
    if (~exist('bucketfordicom','var'))
        bucketfordicom=tmp.bucketfordicom;
    end;
end;

if (~exist('dontcloseexistingworkers','var'))
    dontcloseexistingworkers=[];
end;

global defaults;
global aaparallel
global aaworker

if (exist('username','var') && exist('secretkey','var'))
    aaworker.aacc=aacc(username,secretkey);
end

try
    aaworker.parmpath;
catch
    aaworker.parmpath=aaworker_getparmpath(aap,0);
end;

aaworker.username=username;
if (strcmp(aap.directory_conventions.remotefilesystem,'s3'))
    aaworker.bucket=bucket;
    aaworker.bucketfordicom=bucketfordicom;
end;

aap=aws_setupqnames(aap);

aap.internal.pwd=pwd;

if (isempty(aaparallel))
    while(1)
        aaparallel.workerlist=[];
        
        aaparallel.numberofworkers=8;
        
        % aaparallel.retrydelays=[10 60 300 3600 5*3600]; % seconds delay before successive retries
        aaparallel.retrydelays=[2:9 60 300 3600]; % djm: temporary solution to get past memory errors
        
        aaparallel.processkey=round(rand(1)*1e6);
        aaparallel.nextworkernumber=aaparallel.processkey*1000;
        
        
        pth=aaworker_getparmpath(aap,0,true);
        [subpth nme ext]=fileparts(pth);
        fn=dir(fullfile(subpth,['aaworker' num2str(aaparallel.processkey) '*']));
        if (isempty(fn)) % No directories starting with this process key
            break;
        end;
        
    end;
else
    % Clear out all of the old workers: this is non-unionised enterprise
    if (isempty(dontcloseexistingworkers))
        aa_closeallworkers;
    end;
end;



aas_log(aap,0,['AUTOMATIC ANALYSIS ' datestr(now)]);
aas_log(aap,0,'=============================================================');
aas_log(aap,0,sprintf('Parallel process ID %d',aaparallel.processkey));

% Copy SPM defaults from aap structure
defaults=aap.spm.defaults;

% Check AA version
aas_requiresversion(aap);

% Run initialisation modules
aap=aas_doprocessing_initialisationmodules(aap);

% Save AAP structure
aapsavefn=fullfile(aap.acq_details.root,'aap_parameters');
if (isempty(dir(aap.acq_details.root)))
    [s w]=aas_shell(['mkdir ' aap.acq_details.root]);
    if (s)
        aas_log(aap,1,sprintf('Problem making directory%s',aap.acq_details.root));
    end;
end;
aap.internal.aapversion=which('aa_doprocessing');
save(aapsavefn,'aap');


% THE MODULES IN AAP.TASKLIST.STAGES ARE RUN IF A CORRESPONDING DONE_ FLAG
% IS NOT FOUND. ONE IS CREATED AFTER SUCCESSFUL EXECUTION
% Now run stage-by-stage tasks

% get dependencies of stages, referenced in both directions (aap.internal.dependenton
% and aap.internal.dependencyof)

aap=builddependencymap(aap);

% Use input and output stream information in XML header to find
% out what data comes from where and goes where
aap=findinputstreamsources(aap);

% Store these initial settings before any module specific customisation
aap.internal.aap_initial=aap;
aap.internal.aap_initial.aap.internal.aap_initial=[]; % Prevent recursively expanding storage

% Choose where to run all tasks
switch (aap.options.wheretoprocess)
    case 'localsingle'
        taskqueue=aaq_localsingle(aap);
    case 'localparallel'
        taskqueue=aaq_localparallel(aap);
    case 'aws'
        taskqueue=aaq_aws(aap);
    otherwise
        aas_log(aap,true,sprintf('Unknown aap.options.wheretoprocess, %s\n',aap.options.wheretoprocess));
end;



mytasks={'checkrequirements','doit'}; %
for l=1:length(mytasks)
    for k=1:length(aap.tasklist.main.module)
        task=mytasks{l};
        % allow full path of module to be provided [djm]
        [stagepath stagename]=fileparts(aap.tasklist.main.module(k).name);
           
        aap=aas_setcurrenttask(aap,k);
        
        % retrieve description from module
        description=aap.schema.tasksettings.(stagename).ATTRIBUTE.desc;
        
        % find out whether this module needs to be executed once per study, subject or session
        domain=aap.schema.tasksettings.(stagename).ATTRIBUTE.domain;
        
        %  If multiple repetitions of a module, add 02,03 etc to end of doneflag
        doneflagname=aas_doneflag_getname(aap,k);
        % Start setting up the descriptor for the parallel queue
        clear taskmask
        taskmask.domain=domain;
        taskmask.k=k;
        taskmask.task=task;
        taskmask.stagename=stagename;
        
        completefirst=aap.internal.dependenton{k};
        
        % What needs to finish depends upon the domain of this stage and
        % the previous one. So, if both are session level, then the single
        % session needs to finish the previous stage before the next stage
        % starts on this session. If the latter is subject level, all of
        % the sessions must finish.
        % Now execute the module, and change the 'done' flags if task='doit'
        switch (domain)
            case 'study'
                doneflag=aas_doneflag_getpath(aap,k);
                if (aas_doneflagexists(aap,doneflag))
                    if (strcmp(task,'doit'))
                        aas_log(aap,0,sprintf('- completed previously: %s',description));
                    end;
                else
                    switch (task)
                        case 'checkrequirements'
                            [aap,resp]=aa_feval(aap.tasklist.main.module(k).name,aap,task);
                            if (length(resp)>0)
                                aas_log(aap,0,['\n***WARNING: ' resp]);
                            end;
                        case 'doit'
                            tic
                            % before starting current stage, delete done_
                            % flag for stages that are dependencies of it
                            for k0i=1:length(aap.internal.dependencyof{k})
                                aas_delete_doneflag(aap,aap.internal.dependencyof{k}(k0i).stage);
                            end;
                            
                            % work out what needs to be done before we can
                            % execute this stage
                            completefirst=aap.internal.dependenton{k};
                            tbcf=[];
                            
                            % allow multiple dependecies
                            for k0i=1:length(completefirst)
                                
                                switch(completefirst(k0i).domain)
                                    case 'study'
                                        tbcf={aas_doneflag_getpath(aap,completefirst(k0i).stage)};
                                    case 'subject'
                                        for i=1:length(aap.acq_details.subjects)
                                            tbcf=[tbcf {aas_doneflag_getpath(aap,i,completefirst(k0i).stage)}];
                                        end;
                                    case 'session'
                                        for i=1:length(aap.acq_details.subjects)
                                            for j=1:length(aap.acq_details.sessions)
                                                tbcf=[tbcf {aas_doneflag_getpath(aap,i,j,completefirst(k0i).stage)}];
                                            end;
                                        end;
                                    case 'internal'
                                        load(fullfile(aap.acq_details.root,[aas_getstagetag(aap,completefirst(k0i).stage) '.parallel.mat']))
                                        for x=1:length(loopvar)
                                            if ischar(loopvar{x})
                                                previousdoneflag=fullfile(aas_doneflag_getpath(aap,completefirst(k0i).stage),[loopvar{x} '.done']); % file in directory
                                            elseif isstruct(loopvar{x})
                                                try c={loopvar{x}.id};
                                                catch c=strcat(struct2cell(loopvar{x}),'.'); % Convert structure to cell
                                                end
                                                previousdoneflag=fullfile(aas_doneflag_getpath(aap,completefirst(k0i).stage),[c{:} 'done']); % file in directory
                                            end
                                            tbcf=[tbcf {previousdoneflag}];
                                        end
                                end;
                            end;
                            taskmask.tobecompletedfirst=tbcf;
                            taskmask.i=0;
                            taskmask.j=0;
                            
                            % now queue current stage
                            aas_log(aap,0,sprintf('MODULE %s QUEUED: %s',aap.tasklist.main.module(k).name,description));
                            taskmask.doneflag=doneflag;
                            taskmask.description=description;
                            taskqueue.addtask(taskmask);
                    end;
                    
                end;
            case 'subject'
                for i=1:length(aap.acq_details.subjects)
                    doneflag=aas_doneflag_getpath(aap,i,k);
                    if (aas_doneflagexists(aap,doneflag))
                        if (strcmp(task,'doit'))
                            aas_log(aap,0,sprintf('- completed previously: %s for %s',description,aas_getsubjname(aap,i)));
                        end;
                    else
                        switch (task)
                            case 'checkrequirements'
                                [aap,resp]=aa_feval(aap.tasklist.main.module(k).name,aap,task,i);
                                if (length(resp)>0)
                                    aas_log(aap,0,['\n***WARNING: ' resp]);
                                end;
                            case 'doit'
                                tic
                                % before starting current stage, delete done_
                                % flag for next one
                                for k0i=1:length(aap.internal.dependencyof{k})
                                    aas_delete_doneflag(aap,aap.internal.dependencyof{k}(k0i).stage,i);
                                end;
                                
                                % work out what needs to be done before we can
                                % execute this stage
                                completefirst=aap.internal.dependenton{k};
                                tbcf=[];
                                for k0i=1:length(completefirst)
                                    switch(completefirst(k0i).domain)
                                        case 'study'
                                            tbcf={aas_doneflag_getpath(aap,completefirst(k0i).stage)};
                                        case 'subject'
                                            tbcf=[tbcf {aas_doneflag_getpath(aap,i,completefirst(k0i).stage)}];
                                        case 'session'
                                            for j=1:length(aap.acq_details.sessions)
                                                tbcf=[tbcf {aas_doneflag_getpath(aap,i,j,completefirst(k0i).stage)}];
                                            end;
                                        case 'internal'
                                            load(fullfile(aap.acq_details.root,[aas_getstagetag(aap,completefirst(k0i).stage) '.parallel.mat']))
                                            for x=1:length(loopvar)
                                                if ischar(loopvar{x})
                                                    previousdoneflag=fullfile(aas_doneflag_getpath(aap,completefirst(k0i).stage),[loopvar{x} '.done']); % file in directory
                                                elseif isstruct(loopvar{x})
                                                    try c={loopvar{x}.id};
                                                    catch c=strcat(struct2cell(loopvar{x}),'.'); % Convert structure to cell
                                                    end
                                                    previousdoneflag=fullfile(aas_doneflag_getpath(aap,completefirst(k0i).stage),[c{:} 'done']); % file in directory
                                                end
                                                tbcf=[tbcf {previousdoneflag}];
                                            end
                                    end;
                                end;
                                taskmask.tobecompletedfirst=tbcf;
                                
                                % now queue current stage
                                aas_log(aap,0,sprintf('MODULE %s QUEUED: %s for %s',stagename,description,aas_getsubjname(aap,i)));
                                taskmask.i=i;
                                taskmask.j=0;
                                taskmask.doneflag=doneflag;
                                taskmask.description=sprintf('%s for %s',description,aas_getsubjname(aap,i));
                                taskqueue.addtask(taskmask);
                        end;
                    end;
                end;
                
            case 'session'
                for i=1:length(aap.acq_details.subjects)
                    for j=1:length(aap.acq_details.sessions)
                        doneflag=aas_doneflag_getpath(aap,i,j,k);
                        if (aas_doneflagexists(aap,doneflag))
                            if (strcmp(task,'doit'))
                                aas_log(aap,0,sprintf('- completed previously: %s for %s ',description,aas_getsessname(aap,i,j)));
                            end;
                        else
                            switch (task)
                                case 'checkrequirements'
                                    [aap,resp]=aa_feval(aap.tasklist.main.module(k).name,aap,task,i,j);
                                    if (length(resp)>0)
                                        aas_log(aap,0,['\n***WARNING: ' resp]);
                                    end;
                                case 'doit'
                                    tic
                                    % before starting current stage, delete done_
                                    % flag for next one
                                    for k0i=1:length(aap.internal.dependencyof{k})
                                        aas_delete_doneflag(aap,aap.internal.dependencyof{k}(k0i).stage,i,j);
                                    end;
                                    
                                    % work out what needs to be done before we can
                                    % execute this stage
                                    completefirst=aap.internal.dependenton{k};
                                    tbcf=[];
                                    for k0i=1:length(completefirst)
                                        switch(completefirst(k0i).domain)
                                            case 'study'
                                                tbcf={aas_doneflag_getpath(aap,completefirst(k0i).stage)};
                                            case 'subject'
                                                tbcf=[tbcf {aas_doneflag_getpath(aap,i,completefirst(k0i).stage)}];
                                            case 'session'
                                                tbcf=[tbcf {aas_doneflag_getpath(aap,i,j,completefirst(k0i).stage)}];
                                            case 'internal'
                                                load(fullfile(aap.acq_details.root,[aas_getstagetag(aap,completefirst(k0i).stage) '.parallel.mat']))
                                                for x=1:length(loopvar)
                                                    if ischar(loopvar{x})
                                                        previousdoneflag=fullfile(aas_doneflag_getpath(aap,completefirst(k0i).stage),[loopvar{x} '.done']); % file in directory
                                                    elseif isstruct(loopvar{x})
                                                        try c={loopvar{x}.id};
                                                        catch c=strcat(struct2cell(loopvar{x}),'.'); % Convert structure to cell
                                                        end
                                                        previousdoneflag=fullfile(aas_doneflag_getpath(aap,completefirst(k0i).stage),[c{:} 'done']); % file in directory
                                                    end
                                                    tbcf=[tbcf {previousdoneflag}];
                                                end
                                        end;
                                    end;
                                    taskmask.tobecompletedfirst=tbcf;
                                    
                                    % now queue current stage
                                    aas_log(aap,0,sprintf('MODULE %s QUEUED: %s for %s',stagename,description,aas_getsessname(aap,i,j)));
                                    taskmask.i=i;
                                    taskmask.j=j;
                                    taskmask.description=sprintf('%s for %s',description,aas_getsessname(aap,i,j));
                                    taskmask.doneflag=doneflag;
                                    taskqueue.addtask(taskmask);
                            end;
                        end;
                    end;
                end;
                
            case 'internal' % e.g. for parallelising contrasts at group level [djm]
                switch (task)
                    case 'checkrequirements'
                        [aap,resp]=aa_feval(aap.tasklist.main.module(k).name,aap,task,i);
                        if (length(resp)>0)
                            aas_log(aap,0,['\n***WARNING: ' resp]);
                        end;
                    case 'doit'
                        % work out what needs to be done before we can
                        % execute this stage
                        completefirst=aap.internal.dependenton{k};
                        tbcf=[];
                        % allow multiple dependecies
                        for k0i=1:length(completefirst)
                            switch(completefirst(k0i).domain)
                                case 'study'
                                    tbcf={aas_doneflag_getpath(aap,completefirst(k0i).stage)};
                                case 'subject'
                                    for i=1:length(aap.acq_details.subjects)
                                        tbcf=[tbcf {aas_doneflag_getpath(aap,i,completefirst(k0i).stage)}];
                                    end;
                                case 'session'
                                    for i=1:length(aap.acq_details.subjects)
                                        for j=1:length(aap.acq_details.sessions)
                                            tbcf=[tbcf {aas_doneflag_getpath(aap,i,j,completefirst(k0i).stage)}];
                                        end;
                                        
                                    end;
                                case 'internal'
                                    load(fullfile(aap.acq_details.root,...
                                        sprintf('%s_%g.parallel.mat', ...
                                        aas_getstagetag(aap,completefirst(k0i).stage), ...
                                        aap.tasklist.main.module(completefirst(k0i).stage).index)));
                                    for x=1:length(loopvar)
                                        if ischar(loopvar{x})
                                            previousdoneflag=fullfile(aas_doneflag_getpath(aap,completefirst(k0i).stage),[loopvar{x} '.done']); % file in directory
                                        elseif isstruct(loopvar{x})
                                            try c={loopvar{x}.id};
                                            catch c=strcat(struct2cell(loopvar{x}),'.'); % Convert structure to cell
                                            end
                                            previousdoneflag=fullfile(aas_doneflag_getpath(aap,completefirst(k0i).stage),[c{:} 'done']); % file in directory
                                        end
                                        tbcf=[tbcf {previousdoneflag}];
                                    end
                            end;
                        end;
                        doneflag=aas_doneflag_getpath(aap,k);% this will be a directory
                        joblist=fullfile(aap.acq_details.root, ...
                            sprintf('%s_%g.parallel.mat',stagename,aap.tasklist.main.module(k).index));
                        if (length(dir(doneflag))) && exist(joblist,'file') && 1==2; % let's reparallelise every time to check for new levels (should be pretty quick)
                            aas_log(aap,0,sprintf('- completed previously: parallelise %s', stagename));
                            load(joblist);
                            for x=1:length(loopvar)
                                if ischar(loopvar{x})
                                    doneflag=fullfile(aas_doneflag_getpath(aap,k),[loopvar{x} '.done']); % file in directory
                                    desc=loopvar{x};
                                elseif isstruct(loopvar{x})
                                    try c={loopvar{x}.id};
                                    catch c=strcat(struct2cell(loopvar{x}),'.'); % Convert structure to cell
                                    end
                                    doneflag=fullfile(aas_doneflag_getpath(aap,k),[c{:} 'done']); % file in directory
                                    desc=[c{:}];
                                end
                                if (aas_doneflagexists(aap,doneflag))
                                    aas_log(aap,0,sprintf('- completed previously: %s for %s',stagename,desc));
                                else
                                    % before starting current stage, delete done_
                                    % flag for next one
                                    for k0i=1:length(aap.internal.dependencyof{k})
                                        aas_delete_doneflag(aap,aap.internal.dependencyof{k}(k0i).stage,i);
                                    end;
                                    
                                    % now queue current stage
                                    aas_log(aap,0,sprintf('MODULE %s QUEUED: for %s',stagename,desc));
                                    taskmask.i=x;
                                    taskmask.j=0;
                                    taskmask.doneflag=doneflag;
                                    taskmask.tobecompletedfirst=tbcf;
                                    taskmask.description=sprintf('%s for %s',description,desc);
                                    taskqueue.addtask(taskmask);
                                    
                                end;
                            end;
                        else
                            taskmask.tobecompletedfirst=tbcf;
                            taskmask.i=0; taskmask.j=0;
                            taskmask.doneflag=doneflag;
                            taskmask.description=description;
                            
                            % delete directory for doneflags of children?
                            %if exist(doneflag,'dir'); rmdir(doneflag,'s'); end
                            
                            % now queue current stage; this will define
                            
                            % looping variable and variables global to
                            % iterations, and save in (stagename).parallel.mat
                            aas_log(aap,0,sprintf('MODULE %s QUEUED: %s',stagename,'parallelise'));
                            taskqueue.addtask(taskmask);
                            %[aap,resp]=aa_feval(aap.tasklist.main.module(k).name,aap,'parallelise');
                        end
                end;
                
            otherwise
                aas_log(aap,1,sprintf('Unknown domain %s associated with stage %s',aap.tasklist.domain{k},aap.tasklist.main.module(k).name));
        end;
    end;
end;

taskqueue.runall(dontcloseexistingworkers);

return;






%% BUILD DEPENDENCY MAP
function [aap]=builddependencymap(aap)

aap.internal.dependenton=cell(length(aap.tasklist.main.module),1);
aap.internal.dependencyof=cell(length(aap.tasklist.main.module),1);

for k1=1:length(aap.tasklist.main.module)
    % Default is no dependencies
    completefirst=[];
    
    % first stage has no dependencies
    if (k1>1)
        
        tobecompletedfirst=aap.tasklist.main.module(k1).tobecompletedfirst;
        
        % Defaults to previous stage
         if (isempty(tobecompletedfirst))
             tobecompletedfirst={'[previous]'};
         end; 
        if (~iscell(tobecompletedfirst) && ~isempty(tobecompletedfirst))
            tobecompletedfirst={tobecompletedfirst};
        end;
        
        for k0i=1:length(tobecompletedfirst)
            % previous stage, or something elsE?
            if (strcmp(tobecompletedfirst{k0i},'[previous]'))  % empty now same as [previous]
                completefirst(k0i).stage=k1-1;
            elseif (strcmp(tobecompletedfirst{k0i},'[none]'))   %... so none must be explcitly specified
            else
                for k0=1:k1
                    % allow full path of module to be provided
                    stagetag=aas_getstagetag(aap,k0);
                    if strcmp(stagetag,tobecompletedfirst{k0i})
                        break;
                    end;
                    if (k0==k1)
                        aas_log(aap,1,sprintf('%s is only to be executed after %s, but this is not in the task list',aap.tasklist.main.module(k1).name,tobecompletedfirst{k0i}));
                    end;
                end;
                completefirst(k0i).stage=k0;
            end;
            % now find out what domain the done flags need to cover
            % allow full path of module to be provided
            [stagepath stagename]=fileparts(aap.tasklist.main.module(completefirst(k0i).stage).name);
            completefirst(k0i).domain=aap.schema.tasksettings.(stagename).ATTRIBUTE.domain;
        end;
        
        aap.internal.dependenton{k1}=completefirst;
        
        % now produce indexing the other way, to map
        % aap.internal.dependencyof
        [stagepath stagename]=fileparts(aap.tasklist.main.module(k1).name);
        thisstage=[];
        thisstage.stage=k1;
        thisstage.domain=aap.schema.tasksettings.(stagename).ATTRIBUTE.domain;
        for k0i=1:length(completefirst)
            aap.internal.dependencyof{completefirst(k0i).stage}=[aap.internal.dependencyof{completefirst(k0i).stage} thisstage];
        end;
    end;
    
end;


%% CONNECT DATA PIPELINE BY IDENTIFYING SOURCE OF INPUT FROM OUTPUT STREAMS
%   Works back through dependencies to determine where inputs come from
function [aap]=findinputstreamsources(aap)

aap.internal.inputstreamsources=cell(length(aap.tasklist.main.module),1);
aap.internal.outputstreamdestinations=cell(length(aap.tasklist.main.module),1);
for k1=1:length(aap.tasklist.main.module)
    [stagepath stagename]=fileparts(aap.tasklist.main.module(k1).name);
    if (isfield(aap.schema.tasksettings.(stagename),'inputstreams'))
        inputstreams=aap.schema.tasksettings.(stagename).inputstreams;
        
        for i=1:length(inputstreams.stream)
            [aap stagethatoutputs mindepth]=searchforoutput(aap,k1,inputstreams.stream{i},true,0,inf);
            if isempty(stagethatoutputs)
                aas_log(aap,false,sprintf('Stage %s required input %s is not an output of any stage it is dependent on - so hopefully a primary input?',stagename,inputstreams.stream{i}));
            else
                [sourcestagepath sourcestagename]=fileparts(aap.tasklist.main.module(stagethatoutputs).name);
                aas_log(aap,false,sprintf('Stage %s input %s comes from %s which is %d dependencies prior',stagename,inputstreams.stream{i},sourcestagename,mindepth));
                stream=[];
                stream.name=inputstreams.stream{i};
                stream.sourcenumber=stagethatoutputs;
                stream.sourcestagename=sourcestagename;
                stream.depth=mindepth;
                if (~isfield(aap.internal.inputstreamsources{k1},'stream'))
                    aap.internal.inputstreamsources{k1}.stream=stream;
                else
                    aap.internal.inputstreamsources{k1}.stream(end+1)=stream;
                end;
            end;
        end;
    end;
end;


% RECURSIVELY SEARCH DEPENDENCIES
%  to see which will have outputted each
%  input required for this stage
%  note that inputs can be affected by dependency map
function [aap,stagethatoutputs,mindepth]=searchforoutput(aap,currentstage,outputtype,notthislevelplease,depth,mindepth)

% is this branch ever going to do better than we already have?
if (depth>=mindepth)
    return;
end;

stagethatoutputs=[];

% Search the current level, see if it provides the required output
if (~notthislevelplease)
    depth=depth+1;
    [stagepath stagename]=fileparts(aap.tasklist.main.module(currentstage).name);
    if (isfield(aap.schema.tasksettings.(stagename),'outputstreams'))
        outputstreams=aap.schema.tasksettings.(stagename).outputstreams;
        for i=1:length(outputstreams.stream)
            if (strcmp(outputtype,outputstreams.stream{i}))
                stagethatoutputs=currentstage;
                mindepth=depth;
            end;
        end;
    end;
end;

% If not found, search backwards further
if (isempty(stagethatoutputs))
    dependenton=aap.internal.dependenton{currentstage};
    for i=1:length(dependenton)
        [aap stagethatoutputs mindepth]=searchforoutput(aap,dependenton(i).stage,outputtype,false,depth,mindepth);
    end;
end;





